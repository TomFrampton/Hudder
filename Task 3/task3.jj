/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. task3.jj */
/*@egen*/options {
	             
	               
}

// Lexer
PARSER_BEGIN(Hudder)

	import java.util.Hashtable;

	import java.io.FileInputStream;
	import java.io.FileNotFoundException;

	import Model.Function;

	class Hudder/*@bgen(jjtree)*/implements HudderTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTHudderState jjtree = new JJTHudderState();

/*@egen*/

		public static Hashtable<String, Function> functions = new Hashtable<String, Function>();
		
		public static void main(String[] args) throws ParseException, TokenMgrError, FileNotFoundException {
	
			Hudder parser = null;

			// If file name supplied use the file, otherwise use System.in
			if(args.length > 0) {
				parser = new Hudder(new FileInputStream("./Programs/" + args[0]));
			} else {
				parser = new Hudder(System.in);
			}

			SimpleNode tree = parser.Hudder();

			System.out.println();
			System.out.println("Program:");

			HudderDefaultVisitor printVisitor = new HudderDefaultVisitor();
			tree.jjtAccept(printVisitor, null);
		}
	}

PARSER_END(Hudder)

// Tokens for Lexical Analysis

SKIP : {" "} // Ignore whitespace
SKIP : {"\t"} // Ignore tabs
SKIP : {"\n" | "\r" | "\r\n"} // Ignore newlines

// Ignore multi line comments
SKIP : { <"|=">: INSIDE_COMMENT }

<INSIDE_COMMENT>
SKIP: { <"=|">: DEFAULT | <~[]> }

// Keywords
TOKEN : {< FUN: "fun" >}
TOKEN : {< HANDBACK: "handback" >}
TOKEN : {< REPEAT: "repeat" >}
TOKEN : {< UNTIL: "until" >}
TOKEN : {< WHENEVER: "whenever" >}
TOKEN : {< DO: "do" >}
TOKEN : {< OTHERWISE: "otherwise" >}
TOKEN : {< START: "start" >}
TOKEN : {< STOP: "stop" >}
TOKEN : {< AND: "and" >}
TOKEN : {< OR: "or" >}
TOKEN : {< VAR: "var" >}
TOKEN : {< OUTPUT: "output" >}
// Not required in Task 1
TOKEN : {< IF: "if">}
TOKEN : {< THEN: "then">}
TOKEN : {< ELSE: "else">}
TOKEN : {< NOT : "!" >}

TOKEN : {< IDENTIFIER: ["a"-"z","A"-"Z"](["a"-"z","A"-"Z","0"-"9","_"])* > }	
TOKEN : {< STRING : "\".*\"" >}

TOKEN : {< NUMBER: (["0"-"9"])+ >}

TOKEN : {< PLUS: "+" >}
TOKEN : {< MINUS: "-" >}
TOKEN : {< MULT: "*" >}
TOKEN : {< DIV: "/" >}
TOKEN : {< ASSIGNMENT: ":=" >}
TOKEN : {< EQUAL: "==">}
TOKEN : {< NOT_EQUAL: "!=" >}
TOKEN : {< GREATER: ">" >}
TOKEN : {< LESS: "<" >}
TOKEN : {< GREATER_EQUAL: ">=" >}
TOKEN : {< LESS_EQUAL: "<=" >}
TOKEN : {< O_PAR: "(" >}
TOKEN : {< C_PAR: ")" >}
TOKEN : {< COMMA: ",">}
TOKEN : {< SEMI_COLON: ";" >}


// Parser

SimpleNode Hudder() :
{/*@bgen(jjtree) Hudder */
  ASTHudder jjtn000 = new ASTHudder(JJTHUDDER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Hudder */
        try {
/*@egen*/
	(FunctionDef())* MainProg() <EOF>/*@bgen(jjtree)*/
         {
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
         }
/*@egen*/
	 {
    	return jjtn000;
    }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void MainProg()       :
{}
{
	ProgBlock()
}

void FunctionDef()           :
{/*@bgen(jjtree) #Func( 2) */
  ASTFunc jjtn000 = new ASTFunc(JJTFUNC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token id; }
{/*@bgen(jjtree) #Func( 2) */
        try {
/*@egen*/
	<FUN> id = <IDENTIFIER> <O_PAR> ParamList() <C_PAR> ProgBlock()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000,  2);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.value = id.image;
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000,  2);
          }
        }
/*@egen*/
}

void ParamList()                   :
{/*@bgen(jjtree) #ParamList(> - 1) */
  ASTParamList jjtn000 = new ASTParamList(JJTPARAMLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #ParamList(> - 1) */
        try {
/*@egen*/
	(Param() (<COMMA> Param() )* )?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > - 1);
          }
        }
/*@egen*/
}

void Param()           :
{/*@bgen(jjtree) #Param( 0) */
 ASTParam jjtn000 = new ASTParam(JJTPARAM);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) #Param( 0) */
        try {
/*@egen*/
	t = <IDENTIFIER>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000,  0);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.value = t.image;
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000,  0);
          }
        }
/*@egen*/
}

void ProgBlock()                   :
{/*@bgen(jjtree) #ProgBlock(> - 1) */
  ASTProgBlock jjtn000 = new ASTProgBlock(JJTPROGBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #ProgBlock(> - 1) */
        try {
/*@egen*/
	<START> Statements() <STOP>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > - 1);
          }
        }
/*@egen*/
}

void Statements()        :
{}
{
	(Statement() <SEMI_COLON>)*
}

void Statement()                :
{/*@bgen(jjtree) #Statement( 0) */
  ASTStatement jjtn000 = new ASTStatement(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #Statement( 0) */
        try {
/*@egen*/
	LOOKAHEAD(2) (<VAR>)? <IDENTIFIER> <ASSIGNMENT> Expression()
	| <IDENTIFIER> <O_PAR> ParamListCall() <C_PAR>
	| <OUTPUT> (Expression() | <STRING>)
	| <WHENEVER> Condition() <DO> Statements() (<OTHERWISE> Statements())? <STOP>
	| <IF> Condition() <THEN> Statement() <ELSE> Statement()
	| <REPEAT> ProgBlock() <UNTIL> <O_PAR> Condition() <C_PAR>
	| <HANDBACK> Expression()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000,  0);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.value = "Statement";
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000,  0);
          }
        }
/*@egen*/
}

void Expression()                 :
{/*@bgen(jjtree) #Expression( 2) */
 ASTExpression jjtn000 = new ASTExpression(JJTEXPRESSION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) #Expression( 2) */
        try {
/*@egen*/
	Term() ((t = <PLUS> { jjtn000.value = t.image; } | t = <MINUS> { jjtn000.value = t.image; }) Term())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000,  2);
          }
        }
/*@egen*/
}


void Term()           :
{/*@bgen(jjtree) #Term( 0) */
 ASTTerm jjtn000 = new ASTTerm(JJTTERM);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) #Term( 0) */
        try {
/*@egen*/
	Factor() ((t = <MULT> { jjtn000.value = t.image; } | t = <DIV> { jjtn000.value = t.image; }) Factor())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000,  0);
          }
        }
/*@egen*/
}

void Factor()             :
{/*@bgen(jjtree) #Factor( 0) */
  ASTFactor jjtn000 = new ASTFactor(JJTFACTOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #Factor( 0) */
        try {
/*@egen*/
	<IDENTIFIER> | <NUMBER> | (<PLUS> | <MINUS>)? <O_PAR> Expression() <C_PAR>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000,  0);
          }
        }
/*@egen*/
}

void Condition()                :
{/*@bgen(jjtree) #Condition( 0) */
  ASTCondition jjtn000 = new ASTCondition(JJTCONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #Condition( 0) */
        try {
/*@egen*/
	<NOT> Condition()
	| LOOKAHEAD(2) Expression() (<EQUAL> | <NOT_EQUAL> | <GREATER> | <LESS> | <GREATER_EQUAL> | <LESS_EQUAL>) Expression()
	| <O_PAR> Condition() (<AND> | <OR>) Condition() <C_PAR>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000,  0);
          }
        }
/*@egen*/
}

void ParamListCall()                    :
{/*@bgen(jjtree) #ParamListCall( 0) */
  ASTParamListCall jjtn000 = new ASTParamListCall(JJTPARAMLISTCALL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #ParamListCall( 0) */
        try {
/*@egen*/
	(Expression() (<COMMA> Expression())* )?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000,  0);
          }
        }
/*@egen*/
}